// Code generated by toucan. DO NOT EDIT.
package toucan

import (
	"errors"
	"fmt"
	strcase "github.com/iancoleman/strcase"
	"strings"
)

type GlobalPermission string

const (
	GlobalPermissionReadAllUsers    GlobalPermission = "read_all_users"
	GlobalPermissionWriteAllUsers   GlobalPermission = "write_all_users"
	GlobalPermissionReadAllProfiles GlobalPermission = "read_all_profiles"
)

var (
	ErrInvalidGlobalPermission = fmt.Errorf("not a valid GlobalPermission, try [%s]", strings.Join(globalPermissionNames, ", "))
	ErrNilGlobalPermission     = errors.New("value is nil")
)

var (
	globalPermissionMap = map[string]GlobalPermission{
		"read_all_profiles": GlobalPermissionReadAllProfiles,
		"read_all_users":    GlobalPermissionReadAllUsers,
		"write_all_users":   GlobalPermissionWriteAllUsers,
	}
	globalPermissionNames = []string{string(GlobalPermissionReadAllUsers), string(GlobalPermissionWriteAllUsers), string(GlobalPermissionReadAllProfiles)}
)

func (s GlobalPermission) Valid() bool {
	_, err := ParseGlobalPermission(string(s))
	return err == nil
}

func ParseGlobalPermission(s string) (GlobalPermission, error) {
	if x, ok := globalPermissionMap[s]; ok {
		return x, nil
	}

	// Try to parse from snake case
	if x, ok := globalPermissionMap[strcase.ToSnake(s)]; ok {
		return x, nil
	}

	return "", fmt.Errorf("%s is %w", s, ErrInvalidGlobalPermission)
}

type GlobalRole string

const (
	GlobalRoleAdmin GlobalRole = "admin"
)

var (
	ErrInvalidGlobalRole = fmt.Errorf("not a valid GlobalRole, try [%s]", strings.Join(globalRoleNames, ", "))
	ErrNilGlobalRole     = errors.New("value is nil")
)

var (
	globalRoleMap   = map[string]GlobalRole{"admin": GlobalRoleAdmin}
	globalRoleNames = []string{string(GlobalRoleAdmin)}
)

func (s GlobalRole) Valid() bool {
	_, err := ParseGlobalRole(string(s))
	return err == nil
}

func ParseGlobalRole(s string) (GlobalRole, error) {
	if x, ok := globalRoleMap[s]; ok {
		return x, nil
	}

	// Try to parse from snake case
	if x, ok := globalRoleMap[strcase.ToSnake(s)]; ok {
		return x, nil
	}

	return "", fmt.Errorf("%s is %w", s, ErrInvalidGlobalRole)
}

type RepositoryPermission string

const (
	RepositoryPermissionRead      RepositoryPermission = "read"
	RepositoryPermissionPush      RepositoryPermission = "push"
	RepositoryPermissionDelete    RepositoryPermission = "delete"
	RepositoryPermissionSnakeCase RepositoryPermission = "snake_case"
)

var (
	ErrInvalidRepositoryPermission = fmt.Errorf("not a valid RepositoryPermission, try [%s]", strings.Join(repositoryPermissionNames, ", "))
	ErrNilRepositoryPermission     = errors.New("value is nil")
)

var (
	repositoryPermissionMap = map[string]RepositoryPermission{
		"delete":     RepositoryPermissionDelete,
		"push":       RepositoryPermissionPush,
		"read":       RepositoryPermissionRead,
		"snake_case": RepositoryPermissionSnakeCase,
	}
	repositoryPermissionNames = []string{string(RepositoryPermissionRead), string(RepositoryPermissionPush), string(RepositoryPermissionDelete), string(RepositoryPermissionSnakeCase)}
)

func (s RepositoryPermission) Valid() bool {
	_, err := ParseRepositoryPermission(string(s))
	return err == nil
}

func ParseRepositoryPermission(s string) (RepositoryPermission, error) {
	if x, ok := repositoryPermissionMap[s]; ok {
		return x, nil
	}

	// Try to parse from snake case
	if x, ok := repositoryPermissionMap[strcase.ToSnake(s)]; ok {
		return x, nil
	}

	return "", fmt.Errorf("%s is %w", s, ErrInvalidRepositoryPermission)
}

type RepositoryRole string

const (
	RepositoryRoleOwner  RepositoryRole = "owner"
	RepositoryRoleEditor RepositoryRole = "editor"
	RepositoryRoleViewer RepositoryRole = "viewer"
)

var (
	ErrInvalidRepositoryRole = fmt.Errorf("not a valid RepositoryRole, try [%s]", strings.Join(repositoryRoleNames, ", "))
	ErrNilRepositoryRole     = errors.New("value is nil")
)

var (
	repositoryRoleMap = map[string]RepositoryRole{
		"editor": RepositoryRoleEditor,
		"owner":  RepositoryRoleOwner,
		"viewer": RepositoryRoleViewer,
	}
	repositoryRoleNames = []string{string(RepositoryRoleOwner), string(RepositoryRoleEditor), string(RepositoryRoleViewer)}
)

func (s RepositoryRole) Valid() bool {
	_, err := ParseRepositoryRole(string(s))
	return err == nil
}

func ParseRepositoryRole(s string) (RepositoryRole, error) {
	if x, ok := repositoryRoleMap[s]; ok {
		return x, nil
	}

	// Try to parse from snake case
	if x, ok := repositoryRoleMap[strcase.ToSnake(s)]; ok {
		return x, nil
	}

	return "", fmt.Errorf("%s is %w", s, ErrInvalidRepositoryRole)
}

type UserPermission string

const (
	UserPermissionRead   UserPermission = "read"
	UserPermissionWrite  UserPermission = "write"
	UserPermissionDelete UserPermission = "delete"
)

var (
	ErrInvalidUserPermission = fmt.Errorf("not a valid UserPermission, try [%s]", strings.Join(userPermissionNames, ", "))
	ErrNilUserPermission     = errors.New("value is nil")
)

var (
	userPermissionMap = map[string]UserPermission{
		"delete": UserPermissionDelete,
		"read":   UserPermissionRead,
		"write":  UserPermissionWrite,
	}
	userPermissionNames = []string{string(UserPermissionRead), string(UserPermissionWrite), string(UserPermissionDelete)}
)

func (s UserPermission) Valid() bool {
	_, err := ParseUserPermission(string(s))
	return err == nil
}

func ParseUserPermission(s string) (UserPermission, error) {
	if x, ok := userPermissionMap[s]; ok {
		return x, nil
	}

	// Try to parse from snake case
	if x, ok := userPermissionMap[strcase.ToSnake(s)]; ok {
		return x, nil
	}

	return "", fmt.Errorf("%s is %w", s, ErrInvalidUserPermission)
}

type UserRole string

const (
	UserRoleAdmin  UserRole = "admin"
	UserRoleSelf   UserRole = "self"
	UserRoleViewer UserRole = "viewer"
)

var (
	ErrInvalidUserRole = fmt.Errorf("not a valid UserRole, try [%s]", strings.Join(userRoleNames, ", "))
	ErrNilUserRole     = errors.New("value is nil")
)

var (
	userRoleMap = map[string]UserRole{
		"admin":  UserRoleAdmin,
		"self":   UserRoleSelf,
		"viewer": UserRoleViewer,
	}
	userRoleNames = []string{string(UserRoleAdmin), string(UserRoleSelf), string(UserRoleViewer)}
)

func (s UserRole) Valid() bool {
	_, err := ParseUserRole(string(s))
	return err == nil
}

func ParseUserRole(s string) (UserRole, error) {
	if x, ok := userRoleMap[s]; ok {
		return x, nil
	}

	// Try to parse from snake case
	if x, ok := userRoleMap[strcase.ToSnake(s)]; ok {
		return x, nil
	}

	return "", fmt.Errorf("%s is %w", s, ErrInvalidUserRole)
}
