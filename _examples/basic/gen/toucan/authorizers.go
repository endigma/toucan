// Code generated by toucan. DO NOT EDIT.
package toucan

import (
	"context"
	models "github.com/endigma/toucan/_examples/basic/models"
	decision "github.com/endigma/toucan/decision"
)

func (a Authorizer) AuthorizeRepository(ctx context.Context, actor *models.User, action RepositoryPermission, resource *models.Repository) decision.Decision {
	resolver := a.resolver.Repository()

	if !action.Valid() {
		return decision.Error(ErrInvalidRepositoryPermission)
	}

	if resource != nil {
		switch action {
		case RepositoryPermissionRead:
			// Source: attribute - Public
			if result := resolver.HasAttributePublic(ctx, resource); result.Allow {
				return result
			}

		}
	}

	if resource != nil && actor != nil {
		switch action {
		case RepositoryPermissionRead:
			// Source: role - Owner
			if result := resolver.HasRoleOwner(ctx, actor, resource); result.Allow {
				return result
			}

			// Source: role - Editor
			if result := resolver.HasRoleEditor(ctx, actor, resource); result.Allow {
				return result
			}

			// Source: role - Viewer
			if result := resolver.HasRoleViewer(ctx, actor, resource); result.Allow {
				return result
			}

		case RepositoryPermissionPush:
			// Source: role - Owner
			if result := resolver.HasRoleOwner(ctx, actor, resource); result.Allow {
				return result
			}

			// Source: role - Editor
			if result := resolver.HasRoleEditor(ctx, actor, resource); result.Allow {
				return result
			}

		case RepositoryPermissionDelete:
			// Source: role - Owner
			if result := resolver.HasRoleOwner(ctx, actor, resource); result.Allow {
				return result
			}

		case RepositoryPermissionSnakeCase:
			// Source: role - Owner
			if result := resolver.HasRoleOwner(ctx, actor, resource); result.Allow {
				return result
			}

		}
	}

	return decision.Skip("unmatched")
}

func (a Authorizer) AuthorizeUser(ctx context.Context, actor *models.User, action UserPermission, resource *models.User) decision.Decision {
	resolver := a.resolver.User()

	if !action.Valid() {
		return decision.Error(ErrInvalidUserPermission)
	}

	if resource != nil && actor != nil {
		switch action {
		case UserPermissionRead:
			// Source: role - Admin
			if result := resolver.HasRoleAdmin(ctx, actor, resource); result.Allow {
				return result
			}

			// Source: role - Self
			if result := resolver.HasRoleSelf(ctx, actor, resource); result.Allow {
				return result
			}

			// Source: role - Viewer
			if result := resolver.HasRoleViewer(ctx, actor, resource); result.Allow {
				return result
			}

		case UserPermissionWrite:
			// Source: role - Admin
			if result := resolver.HasRoleAdmin(ctx, actor, resource); result.Allow {
				return result
			}

			// Source: role - Self
			if result := resolver.HasRoleSelf(ctx, actor, resource); result.Allow {
				return result
			}

		case UserPermissionDelete:
			// Source: role - Admin
			if result := resolver.HasRoleAdmin(ctx, actor, resource); result.Allow {
				return result
			}

		}
	}

	return decision.Skip("unmatched")
}

// Global authorizer
type Authorizer struct {
	resolver Resolver
}

func (a Authorizer) Authorize(ctx context.Context, actor *models.User, permission string, resource any) decision.Decision {
	switch resource.(type) {
	case *models.Repository:
		perm, err := ParseRepositoryPermission(permission)
		if err == nil {
			return a.AuthorizeRepository(ctx, actor, perm, resource.(*models.Repository))
		}
	case *models.User:
		perm, err := ParseUserPermission(permission)
		if err == nil {
			return a.AuthorizeUser(ctx, actor, perm, resource.(*models.User))
		}
	}

	return decision.Skip("unmatched")
}

func NewAuthorizer(resolver Resolver) *Authorizer {
	return &Authorizer{resolver: resolver}
}
