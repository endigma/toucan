// Code generated by toucan. DO NOT EDIT.
package toucan

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	models "github.com/endigma/toucan/_examples/basic/models"
	conc "github.com/sourcegraph/conc"
)

type Authorizer interface {
	Authorize(ctx context.Context, actor *models.User, permission Permission, resource any) error
}

type AuthorizerFunc func(ctx context.Context, actor *models.User, permission Permission, resource any) error

func (af AuthorizerFunc) Authorize(ctx context.Context, actor *models.User, permission Permission, resource any) error {
	return af(ctx, actor, permission, resource)
}

type authorizerResult struct {
	allow  bool
	source string
	error  error
}

var authorizerData = map[Permission]struct {
	Attributes []Attribute
	Roles      []Role
}{
	PermissionGlobalReadAllProfiles: {
		Attributes: []Attribute{AttributeGlobalProfilesArePublic},
		Roles:      []Role{},
	},
	PermissionGlobalReadAllUsers: {
		Attributes: []Attribute{},
		Roles:      []Role{RoleGlobalAdmin},
	},
	PermissionGlobalWriteAllUsers: {
		Attributes: []Attribute{},
		Roles:      []Role{RoleGlobalAdmin},
	},
	PermissionRepositoryDelete: {
		Attributes: []Attribute{},
		Roles:      []Role{RoleRepositoryOwner},
	},
	PermissionRepositoryPush: {
		Attributes: []Attribute{},
		Roles:      []Role{RoleRepositoryOwner, RoleRepositoryEditor},
	},
	PermissionRepositoryRead: {
		Attributes: []Attribute{AttributeRepositoryPublic},
		Roles:      []Role{RoleRepositoryOwner, RoleRepositoryEditor, RoleRepositoryViewer},
	},
	PermissionRepositorySnakeCase: {
		Attributes: []Attribute{},
		Roles:      []Role{RoleRepositoryOwner},
	},
	PermissionUserDelete: {
		Attributes: []Attribute{},
		Roles:      []Role{RoleUserAdmin},
	},
	PermissionUserRead: {
		Attributes: []Attribute{},
		Roles:      []Role{RoleUserAdmin, RoleUserSelf, RoleUserViewer},
	},
	PermissionUserWrite: {
		Attributes: []Attribute{},
		Roles:      []Role{RoleUserAdmin, RoleUserSelf},
	},
}

// Authorizer
type authorizer struct {
	resolver Resolver
}

func (a authorizer) Authorize(ctx context.Context, actor *models.User, permission Permission, resource any) error {
	var cancel func()
	ctx, cancel = context.WithCancel(ctx)
	defer cancel()

	results := make(chan authorizerResult)
	var wg conc.WaitGroup

	authorizerData, ok := authorizerData[permission]
	if !ok {
		return fmt.Errorf("invalid permission %s", permission)
	}

	for _, attribute := range authorizerData.Attributes {
		attribute := attribute
		wg.Go(func() {
			allow, err := a.resolver.HasAttribute(ctx, resource, attribute)
			results <- authorizerResult{
				allow:  allow,
				error:  err,
				source: fmt.Sprintf("attribute %s", attribute),
			}
		})
	}
	if actor != nil {
		for _, role := range authorizerData.Roles {
			role := role
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, role)
				results <- authorizerResult{
					allow:  allow,
					error:  err,
					source: fmt.Sprintf("role %s", role),
				}
			})
		}
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	var denyReasons []string
	for result := range results {
		if errors.Is(result.error, context.Canceled) {
			continue
		}
		if result.error != nil {
			cancel()
			for range results {
				// drain channel
			}
			return result.error
		}
		if result.allow {
			cancel()
			for range results {
				// drain channel
			}
			return fmt.Errorf("authorize %s: %w: has %s", permission, Allow, result.source)
		}
		denyReasons = append(denyReasons, fmt.Sprintf("%s", result.source))
	}

	sort.Sort(sort.StringSlice(denyReasons))

	return fmt.Errorf("authorize %s: %w: missing %s", permission, Deny, strings.Join(denyReasons, ", "))
}

func NewAuthorizer(resolver Resolver) Authorizer {
	return authorizer{resolver: resolver}
}
