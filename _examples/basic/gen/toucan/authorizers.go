// Code generated by toucan. DO NOT EDIT.
package toucan

import (
	"context"
	"errors"
	"fmt"
	models "github.com/endigma/toucan/_examples/basic/models"
	conc "github.com/sourcegraph/conc"
	"strings"
)

type Authorizer interface {
	Authorize(ctx context.Context, actor *models.User, permission Permission, resource any) error
}

type AuthorizerFunc func(ctx context.Context, actor *models.User, permission Permission, resource any) error

func (af AuthorizerFunc) Authorize(ctx context.Context, actor *models.User, permission Permission, resource any) error {
	return af(ctx, actor, permission, resource)
}

func (a authorizer) authorizeGlobal(ctx context.Context, actor *models.User, action Permission) error {
	var cancel func()
	ctx, cancel = context.WithCancel(ctx)
	defer cancel()

	results := make(chan struct {
		allow  bool
		source string
		error  error
	})
	var wg conc.WaitGroup

	switch action {

	case PermissionGlobalReadAllProfiles:
		// Source: attribute - profiles_are_public
		wg.Go(func() {
			allow, err := a.resolver.HasAttribute(ctx, nil, AttributeGlobalProfilesArePublic)
			results <- struct {
				allow  bool
				source string
				error  error
			}{
				allow:  allow,
				error:  err,
				source: "profiles_are_public attribute",
			}
		})
	}

	if actor != nil {
		switch action {
		case PermissionGlobalReadAllUsers:
			// Source: role - admin
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, nil, RoleGlobalAdmin)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "admin role",
				}
			})

		case PermissionGlobalWriteAllUsers:
			// Source: role - admin
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, nil, RoleGlobalAdmin)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "admin role",
				}
			})
		}
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	var denyReasons []string
	for result := range results {
		if errors.Is(result.error, context.Canceled) {
			continue
		}
		if result.error != nil {
			cancel()
			for range results {
				// drain channel
			}
			return result.error
		}
		if result.allow {
			cancel()
			for range results {
				// drain channel
			}
			return fmt.Errorf("authorize global: %w: has %s", Allow, result.source)
		}
		denyReasons = append(denyReasons, fmt.Sprintf("%s", result.source))
	}
	return fmt.Errorf("authorize global: %w: missing %s", Deny, strings.Join(denyReasons, ", "))
}

func (a authorizer) authorizeRepository(ctx context.Context, actor *models.User, action Permission, resource *models.Repository) error {
	if resource == nil {
		return fmt.Errorf("authorize repository: resource is nil")
	}
	var cancel func()
	ctx, cancel = context.WithCancel(ctx)
	defer cancel()

	results := make(chan struct {
		allow  bool
		source string
		error  error
	})
	var wg conc.WaitGroup

	switch action {
	case PermissionRepositoryRead:
		// Source: attribute - public
		wg.Go(func() {
			allow, err := a.resolver.HasAttribute(ctx, resource, AttributeRepositoryPublic)
			results <- struct {
				allow  bool
				source string
				error  error
			}{
				allow:  allow,
				error:  err,
				source: "public attribute",
			}
		})
	}

	if actor != nil {
		switch action {
		case PermissionRepositoryRead:
			// Source: role - owner
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleRepositoryOwner)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "owner role",
				}
			})

			// Source: role - editor
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleRepositoryEditor)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "editor role",
				}
			})

			// Source: role - viewer
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleRepositoryViewer)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "viewer role",
				}
			})

		case PermissionRepositoryPush:
			// Source: role - owner
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleRepositoryOwner)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "owner role",
				}
			})

			// Source: role - editor
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleRepositoryEditor)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "editor role",
				}
			})

		case PermissionRepositoryDelete:
			// Source: role - owner
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleRepositoryOwner)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "owner role",
				}
			})

		case PermissionRepositorySnakeCase:
			// Source: role - owner
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleRepositoryOwner)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "owner role",
				}
			})
		}
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	var denyReasons []string
	for result := range results {
		if errors.Is(result.error, context.Canceled) {
			continue
		}
		if result.error != nil {
			cancel()
			for range results {
				// drain channel
			}
			return result.error
		}
		if result.allow {
			cancel()
			for range results {
				// drain channel
			}
			return fmt.Errorf("authorize repository: %w: has %s", Allow, result.source)
		}
		denyReasons = append(denyReasons, fmt.Sprintf("%s", result.source))
	}
	return fmt.Errorf("authorize repository: %w: missing %s", Deny, strings.Join(denyReasons, ", "))
}

func (a authorizer) authorizeUser(ctx context.Context, actor *models.User, action Permission, resource *models.User) error {
	if resource == nil {
		return fmt.Errorf("authorize user: resource is nil")
	}
	var cancel func()
	ctx, cancel = context.WithCancel(ctx)
	defer cancel()

	results := make(chan struct {
		allow  bool
		source string
		error  error
	})
	var wg conc.WaitGroup

	if actor != nil {
		switch action {
		case PermissionUserRead:
			// Source: role - admin
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleUserAdmin)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "admin role",
				}
			})

			// Source: role - self
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleUserSelf)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "self role",
				}
			})

			// Source: role - viewer
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleUserViewer)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "viewer role",
				}
			})

		case PermissionUserWrite:
			// Source: role - admin
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleUserAdmin)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "admin role",
				}
			})

			// Source: role - self
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleUserSelf)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "self role",
				}
			})

		case PermissionUserDelete:
			// Source: role - admin
			wg.Go(func() {
				allow, err := a.resolver.HasRole(ctx, actor, resource, RoleUserAdmin)
				results <- struct {
					allow  bool
					source string
					error  error
				}{
					allow:  allow,
					error:  err,
					source: "admin role",
				}
			})
		}
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	var denyReasons []string
	for result := range results {
		if errors.Is(result.error, context.Canceled) {
			continue
		}
		if result.error != nil {
			cancel()
			for range results {
				// drain channel
			}
			return result.error
		}
		if result.allow {
			cancel()
			for range results {
				// drain channel
			}
			return fmt.Errorf("authorize user: %w: has %s", Allow, result.source)
		}
		denyReasons = append(denyReasons, fmt.Sprintf("%s", result.source))
	}
	return fmt.Errorf("authorize user: %w: missing %s", Deny, strings.Join(denyReasons, ", "))
}

// Authorizer
type authorizer struct {
	resolver Resolver
}

func (a authorizer) Authorize(ctx context.Context, actor *models.User, permission Permission, resource any) error {
	switch permission {
	case PermissionGlobalReadAllUsers,
		PermissionGlobalWriteAllUsers,
		PermissionGlobalReadAllProfiles:
		if resource != nil {
			return fmt.Errorf("authorize: invalid resource type %T, wanted nil", resource)
		}
		return a.authorizeGlobal(ctx, actor, permission)
	case PermissionRepositoryRead,
		PermissionRepositoryPush,
		PermissionRepositoryDelete,
		PermissionRepositorySnakeCase:
		resource, ok := resource.(*models.Repository)
		if !ok {
			return fmt.Errorf("authorize: invalid resource type %T for repository, wanted *github.com/endigma/toucan/_examples/basic/models.Repository", resource)
		}
		return a.authorizeRepository(ctx, actor, permission, resource)
	case PermissionUserRead,
		PermissionUserWrite,
		PermissionUserDelete:
		resource, ok := resource.(*models.User)
		if !ok {
			return fmt.Errorf("authorize: invalid resource type %T for user, wanted *github.com/endigma/toucan/_examples/basic/models.User", resource)
		}
		return a.authorizeUser(ctx, actor, permission, resource)
	}

	return fmt.Errorf("invalid permission %s", permission)
}

func NewAuthorizer(resolver Resolver) Authorizer {
	return authorizer{resolver: resolver}
}
