// Code generated by toucan. DO NOT EDIT.
package toucan

import (
	"context"
	models "github.com/endigma/toucan/_examples/basic/models"
	decision "github.com/endigma/toucan/decision"
)

type Resolver interface {
	HasRole(ctx context.Context, actor *models.User, resource any, role Role) decision.Decision
	HasAttribute(ctx context.Context, resource any, attribute Attribute) decision.Decision
}

type ResolverFuncs struct {
	Role      func(ctx context.Context, actor *models.User, resource any, role Role) decision.Decision
	Attribute func(ctx context.Context, resource any, attribute Attribute) decision.Decision
}

func (fs ResolverFuncs) HasRole(ctx context.Context, actor *models.User, resource any, role Role) decision.Decision {
	return fs.Role(ctx, actor, resource, role)
}

func (fs ResolverFuncs) HasAttribute(ctx context.Context, resource any, attribute Attribute) decision.Decision {
	return fs.Attribute(ctx, resource, attribute)
}

type resolver struct {
	root ResolverRoot
}

func (r resolver) HasRole(ctx context.Context, actor *models.User, resource any, role Role) decision.Decision {
	switch role {
	case RoleGlobalAdmin:
		return r.root.Global().HasRoleAdmin(ctx, actor)
	case RoleRepositoryOwner:
		return r.root.Repository().HasRoleOwner(ctx, actor, resource.(*models.Repository))
	case RoleRepositoryEditor:
		return r.root.Repository().HasRoleEditor(ctx, actor, resource.(*models.Repository))
	case RoleRepositoryViewer:
		return r.root.Repository().HasRoleViewer(ctx, actor, resource.(*models.Repository))
	case RoleUserAdmin:
		return r.root.User().HasRoleAdmin(ctx, actor, resource.(*models.User))
	case RoleUserSelf:
		return r.root.User().HasRoleSelf(ctx, actor, resource.(*models.User))
	case RoleUserViewer:
		return r.root.User().HasRoleViewer(ctx, actor, resource.(*models.User))
	default:
		return decision.False("unmatched in HasRole: " + string(role))
	}
}

func (r resolver) HasAttribute(ctx context.Context, resource any, attribute Attribute) decision.Decision {
	switch attribute {
	case AttributeGlobalProfilesArePublic:
		return r.root.Global().HasAttributeProfilesArePublic(ctx)
	case AttributeRepositoryPublic:
		return r.root.Repository().HasAttributePublic(ctx, resource.(*models.Repository))
	default:
		return decision.False("unmatched in HasAttribute: " + string(attribute))
	}
}

func NewResolver(root ResolverRoot) Resolver {
	return resolver{root: root}
}

// Resolver for resource `global`
type GlobalResolver interface {
	HasRoleAdmin(ctx context.Context, actor *models.User) decision.Decision
	HasAttributeProfilesArePublic(ctx context.Context) decision.Decision
}

// Resolver for resource `repository`
type RepositoryResolver interface {
	HasRoleOwner(ctx context.Context, actor *models.User, resource *models.Repository) decision.Decision
	HasRoleEditor(ctx context.Context, actor *models.User, resource *models.Repository) decision.Decision
	HasRoleViewer(ctx context.Context, actor *models.User, resource *models.Repository) decision.Decision
	HasAttributePublic(ctx context.Context, resource *models.Repository) decision.Decision
}

// Resolver for resource `user`
type UserResolver interface {
	HasRoleAdmin(ctx context.Context, actor *models.User, resource *models.User) decision.Decision
	HasRoleSelf(ctx context.Context, actor *models.User, resource *models.User) decision.Decision
	HasRoleViewer(ctx context.Context, actor *models.User, resource *models.User) decision.Decision
}

// Root Resolver
type ResolverRoot interface {
	Global() GlobalResolver
	Repository() RepositoryResolver
	User() UserResolver
}
