// Code generated by toucan. DO NOT EDIT.
package toucan

import (
	"context"
	models "github.com/endigma/toucan/_examples/basic/models"
	decision "github.com/endigma/toucan/decision"
)

type Resolver interface {
	HasRole(ctx context.Context, actor *models.User, resource any, resourceType string, role string) decision.Decision
	HasAttribute(ctx context.Context, resource any, resourceType string, attribute string) decision.Decision
}

type resolver struct {
	root ResolverRoot
}

func (r resolver) HasRole(ctx context.Context, actor *models.User, resource any, resourceType string, role string) decision.Decision {
	switch resourceType {
	case "global":
		switch role {
		case string(GlobalRoleAdmin):
			return r.root.Global().HasRoleAdmin(ctx, actor)
		default:
			return decision.False("unmatched in HasRole: " + role)
		}
	case "repository":
		switch role {
		case string(RepositoryRoleOwner):
			return r.root.Repository().HasRoleOwner(ctx, actor, resource.(*models.Repository))
		case string(RepositoryRoleEditor):
			return r.root.Repository().HasRoleEditor(ctx, actor, resource.(*models.Repository))
		case string(RepositoryRoleViewer):
			return r.root.Repository().HasRoleViewer(ctx, actor, resource.(*models.Repository))
		default:
			return decision.False("unmatched in HasRole: " + role)
		}
	case "user":
		switch role {
		case string(UserRoleAdmin):
			return r.root.User().HasRoleAdmin(ctx, actor, resource.(*models.User))
		case string(UserRoleSelf):
			return r.root.User().HasRoleSelf(ctx, actor, resource.(*models.User))
		case string(UserRoleViewer):
			return r.root.User().HasRoleViewer(ctx, actor, resource.(*models.User))
		default:
			return decision.False("unmatched in HasRole: " + role)
		}
	default:
		return decision.False("unmatched in HasRole: " + resourceType)
	}
}

func (r resolver) HasAttribute(ctx context.Context, resource any, resourceType string, attribute string) decision.Decision {
	switch resourceType {
	case "global":
		switch attribute {
		case "profiles_are_public":
			return r.root.Global().HasAttributeProfilesArePublic(ctx)
		default:
			return decision.False("unmatched in HasAttribute: " + attribute)
		}
	case "repository":
		switch attribute {
		case "public":
			return r.root.Repository().HasAttributePublic(ctx, resource.(*models.Repository))
		default:
			return decision.False("unmatched in HasAttribute: " + attribute)
		}
	case "user":
		switch attribute {
		default:
			return decision.False("unmatched in HasAttribute: " + attribute)
		}
	default:
		return decision.False("unmatched in HasAttribute: " + resourceType)
	}
}

func NewResolver(root ResolverRoot) Resolver {
	return resolver{root: root}
}

// Resolver for resource `global`
type GlobalResolver interface {
	HasRoleAdmin(ctx context.Context, actor *models.User) decision.Decision
	HasAttributeProfilesArePublic(ctx context.Context) decision.Decision
}

// Resolver for resource `repository`
type RepositoryResolver interface {
	HasRoleOwner(ctx context.Context, actor *models.User, resource *models.Repository) decision.Decision
	HasRoleEditor(ctx context.Context, actor *models.User, resource *models.Repository) decision.Decision
	HasRoleViewer(ctx context.Context, actor *models.User, resource *models.Repository) decision.Decision
	HasAttributePublic(ctx context.Context, resource *models.Repository) decision.Decision
}

// Resolver for resource `user`
type UserResolver interface {
	HasRoleAdmin(ctx context.Context, actor *models.User, resource *models.User) decision.Decision
	HasRoleSelf(ctx context.Context, actor *models.User, resource *models.User) decision.Decision
	HasRoleViewer(ctx context.Context, actor *models.User, resource *models.User) decision.Decision
}

// Root Resolver
type ResolverRoot interface {
	Global() GlobalResolver
	Repository() RepositoryResolver
	User() UserResolver
}
