// Code generated by toucan. DO NOT EDIT.
package toucan

import (
	"context"
	"fmt"
	models "github.com/endigma/toucan/_examples/basic/models"
)

type Resolver interface {
	HasRole(ctx context.Context, actor *models.User, resource any, role Role) (bool, error)
	HasAttribute(ctx context.Context, resource any, attribute Attribute) (bool, error)
}

type ResolverFuncs struct {
	Role      func(ctx context.Context, actor *models.User, resource any, role Role) (bool, error)
	Attribute func(ctx context.Context, resource any, attribute Attribute) (bool, error)
}

func (fs ResolverFuncs) HasRole(ctx context.Context, actor *models.User, resource any, role Role) (bool, error) {
	return fs.Role(ctx, actor, resource, role)
}

func (fs ResolverFuncs) HasAttribute(ctx context.Context, resource any, attribute Attribute) (bool, error) {
	return fs.Attribute(ctx, resource, attribute)
}

type resolver struct {
	root ResolverRoot
}

func (r resolver) HasRole(ctx context.Context, actor *models.User, resource any, role Role) (bool, error) {
	switch role {
	case RoleGlobalAdmin:
		if resource != nil {
			return false, fmt.Errorf("HasRole: invalid resource type %T, wanted nil", resource)
		}
		return r.root.Global().HasRoleAdmin(ctx, actor)
	case RoleRepositoryOwner:
		repository, ok := resource.(*models.Repository)
		if !ok {
			return false, fmt.Errorf("HasRole: invalid resource type %T, wanted *github.com/endigma/toucan/_examples/basic/models.Repository", resource)
		}
		if repository == nil {
			return false, fmt.Errorf("HasRole: got nil repository")
		}
		return r.root.Repository().HasRoleOwner(ctx, actor, repository)
	case RoleRepositoryEditor:
		repository, ok := resource.(*models.Repository)
		if !ok {
			return false, fmt.Errorf("HasRole: invalid resource type %T, wanted *github.com/endigma/toucan/_examples/basic/models.Repository", resource)
		}
		if repository == nil {
			return false, fmt.Errorf("HasRole: got nil repository")
		}
		return r.root.Repository().HasRoleEditor(ctx, actor, repository)
	case RoleRepositoryViewer:
		repository, ok := resource.(*models.Repository)
		if !ok {
			return false, fmt.Errorf("HasRole: invalid resource type %T, wanted *github.com/endigma/toucan/_examples/basic/models.Repository", resource)
		}
		if repository == nil {
			return false, fmt.Errorf("HasRole: got nil repository")
		}
		return r.root.Repository().HasRoleViewer(ctx, actor, repository)
	case RoleUserAdmin:
		user, ok := resource.(*models.User)
		if !ok {
			return false, fmt.Errorf("HasRole: invalid resource type %T, wanted *github.com/endigma/toucan/_examples/basic/models.User", resource)
		}
		if user == nil {
			return false, fmt.Errorf("HasRole: got nil user")
		}
		return r.root.User().HasRoleAdmin(ctx, actor, user)
	case RoleUserSelf:
		user, ok := resource.(*models.User)
		if !ok {
			return false, fmt.Errorf("HasRole: invalid resource type %T, wanted *github.com/endigma/toucan/_examples/basic/models.User", resource)
		}
		if user == nil {
			return false, fmt.Errorf("HasRole: got nil user")
		}
		return r.root.User().HasRoleSelf(ctx, actor, user)
	case RoleUserViewer:
		user, ok := resource.(*models.User)
		if !ok {
			return false, fmt.Errorf("HasRole: invalid resource type %T, wanted *github.com/endigma/toucan/_examples/basic/models.User", resource)
		}
		if user == nil {
			return false, fmt.Errorf("HasRole: got nil user")
		}
		return r.root.User().HasRoleViewer(ctx, actor, user)
	}
	return false, fmt.Errorf("HasRole: unmatched: %s: %w", role, Deny)
}

func (r resolver) HasAttribute(ctx context.Context, resource any, attribute Attribute) (bool, error) {
	switch attribute {
	case AttributeGlobalProfilesArePublic:
		if resource != nil {
			return false, fmt.Errorf("HasAttribute: invalid resource type %T, wanted nil", resource)
		}
		return r.root.Global().HasAttributeProfilesArePublic(ctx)
	case AttributeRepositoryPublic:
		repository, ok := resource.(*models.Repository)
		if !ok {
			return false, fmt.Errorf("HasAttribute: invalid resource type %T, wanted *github.com/endigma/toucan/_examples/basic/models.Repository", resource)
		}
		if repository == nil {
			return false, fmt.Errorf("HasRole: got nil repository")
		}
		return r.root.Repository().HasAttributePublic(ctx, repository)
	}
	return false, fmt.Errorf("HasAttribute: unmatched: %s: %w", attribute, Deny)
}

func NewResolver(root ResolverRoot) Resolver {
	return resolver{root: root}
}

// Resolver for resource `global`
type GlobalResolver interface {
	HasRoleAdmin(ctx context.Context, actor *models.User) (bool, error)
	HasAttributeProfilesArePublic(ctx context.Context) (bool, error)
}

// Resolver for resource `repository`
type RepositoryResolver interface {
	HasRoleOwner(ctx context.Context, actor *models.User, resource *models.Repository) (bool, error)
	HasRoleEditor(ctx context.Context, actor *models.User, resource *models.Repository) (bool, error)
	HasRoleViewer(ctx context.Context, actor *models.User, resource *models.Repository) (bool, error)
	HasAttributePublic(ctx context.Context, resource *models.Repository) (bool, error)
}

// Resolver for resource `user`
type UserResolver interface {
	HasRoleAdmin(ctx context.Context, actor *models.User, resource *models.User) (bool, error)
	HasRoleSelf(ctx context.Context, actor *models.User, resource *models.User) (bool, error)
	HasRoleViewer(ctx context.Context, actor *models.User, resource *models.User) (bool, error)
}

// Root Resolver
type ResolverRoot interface {
	Global() GlobalResolver
	Repository() RepositoryResolver
	User() UserResolver
}
