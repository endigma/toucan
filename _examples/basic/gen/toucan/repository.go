// Code generated by toucan. DO NOT EDIT.
package policy

import (
	"context"
	"errors"
	"fmt"
	models "github.com/endigma/toucan/_examples/basic/models"
	strcase "github.com/iancoleman/strcase"
	"strings"
)

// resource `repository`

// Enum RepositoryPermission
type RepositoryPermission string

const (
	RepositoryPermissionRead      RepositoryPermission = "read"
	RepositoryPermissionPush      RepositoryPermission = "push"
	RepositoryPermissionDelete    RepositoryPermission = "delete"
	RepositoryPermissionSnakeCase RepositoryPermission = "snake_case"
)

func (s RepositoryPermission) String() string {
	return string(s)
}

func (s RepositoryPermission) Valid() bool {
	_, err := ParseRepositoryPermission(string(s))
	return err == nil
}

var (
	ErrInvalidRepositoryPermission = fmt.Errorf("not a valid repositoryPermission, try [%s]", strings.Join(repositoryPermissionNames, ", "))
	ErrNilRepositoryPermission     = errors.New("value is nil")
)

var (
	repositoryPermissionMap = map[string]RepositoryPermission{
		"delete":     RepositoryPermissionDelete,
		"push":       RepositoryPermissionPush,
		"read":       RepositoryPermissionRead,
		"snake_case": RepositoryPermissionSnakeCase,
	}
	repositoryPermissionNames = []string{string(RepositoryPermissionRead), string(RepositoryPermissionPush), string(RepositoryPermissionDelete), string(RepositoryPermissionSnakeCase)}
)

func ParseRepositoryPermission(s string) (RepositoryPermission, error) {
	if x, ok := repositoryPermissionMap[s]; ok {
		return x, nil
	}

	// Try to parse from snake case
	if x, ok := repositoryPermissionMap[strcase.ToSnake(s)]; ok {
		return x, nil
	}

	return RepositoryPermission(""), fmt.Errorf("%s is %w", s, ErrInvalidRepositoryPermission)
}

// Resolver for resource `repository`
type RepositoryResolver interface {
	HasRoleOwner(context context.Context, actor *models.User, resource *models.Repository) bool
	HasRoleEditor(context context.Context, actor *models.User, resource *models.Repository) bool
	HasRoleViewer(context context.Context, actor *models.User, resource *models.Repository) bool
	HasAttributePublic(context context.Context, resource *models.Repository) bool
}

// Authorizer for resource `repository`
func (a Authorizer) AuthorizeRepository(ctx context.Context, actor *models.User, action RepositoryPermission, resource *models.Repository) bool {
	resolver := a.resolver.Repository()

	if !action.Valid() {
		return false
	}

	if resource != nil {
		switch action {
		case RepositoryPermissionRead:
			if resolver.HasAttributePublic(ctx, resource) {
				return true
			}
		}
	}

	if resource != nil && actor != nil {
		switch action {
		case RepositoryPermissionRead:
			return resolver.HasRoleOwner(ctx, actor, resource) ||
				resolver.HasRoleEditor(ctx, actor, resource) ||
				resolver.HasRoleViewer(ctx, actor, resource)
		case RepositoryPermissionPush:
			return resolver.HasRoleOwner(ctx, actor, resource) ||
				resolver.HasRoleEditor(ctx, actor, resource)
		case RepositoryPermissionDelete:
			return resolver.HasRoleOwner(ctx, actor, resource)
		case RepositoryPermissionSnakeCase:
			return resolver.HasRoleOwner(ctx, actor, resource)
		}
	}

	return false
}
